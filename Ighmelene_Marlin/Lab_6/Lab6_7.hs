module Lab6_7 where

import Data.List
import System.Random
import Lecture6

-- 180 min

{-
Ex 7: 
The recipe: take a prime p, and use the Miller-Rabin algorithm to check whether (2^p)−1 is also prime. 

1) Take a prime p
    *Lab6_7> primes

2) Get (2^p)-1
    *Lab6_7> map (\p -> pred $ 2^p) primes

3) Use the Miller-Rabin algorithm to check whether (2^p)−1 is also prime
    *Lab6_7> testMersenneMillerRabin k (map (\p -> pred $ 2^p) primes)

The mers function in Lecture6 returns the first 25 Mersenne primes.
Those are used to verify that p is indeed a Mersenne prime.
    *Lab6_7> isMersenne 3
    True

    *Lab6_7> getMersenne 3
    1

    *Lab6_7> testMersenneMillerRabin 1024 [3] 1

    Probably prime (k = 1024):  p = 3
    Mersenne prime:  1

Because the numbers are quite large, so even with k=1 it's take long to get pass the 20th number.
    Probably prime (k = 1024):
    28554254222827961390156356610216400832616423864470288919924745660228440039060065387595457150553984323975451391589615029787839937705607143516974722110798879119820098847753133921428277201
    60590099045866862549890848157354224804090223442975883525260043838906326161240763173874168811485924861883618739041757831456960169195743907655982801885990355784485910776836771755204340742
    877265780062667596159707595213278285556627816783856915818444364448125115624281367424904593632128101802760960881114010033775703635457251209240736469215767971461993876192965603026802617901
    18132925012323046444438622308877924609373773012481681672424493674474488537770155783006880852648161513067144814790288366664062257274665275787127374649231096375001170901890786263324619578
    79573142569380507305611967758033808433338198750090296883193591309526982131114132239335649017848872898228815628260081383129614366384594543114404375382154287127774560644785856415921332844
    35802064227146949130917627164470416896780700967735904298089096167504529272580008435003448316282970899027286499819943876472345742762637296948483047509171741861811306885187927486226122933
    413689280566343844666463265724761672756608391056505289757138993202111214957953114279462545533053870678210676017687509778661004600146021384084480212250536890547937420030957220967329547507
    21718115531871310231057902608580607
    Mersenne prime:  20

With k=1 all primes until the 25th number were identified
    Probably prime (k = 1):
    448679166119043334794951410361591778727209023729388613010364804475127856091580536371620183959201831086891496139730355336211345516747152878800071343453471946810257320569398254237235217504
    ...
    812559454134724652462311948814013160716284272817130422478691856312001923336989669335443616293913110417309565016946627545588756443451912692796006935518092719564502642940928574108283535118
    82751
    Mersenne prime:  25

    Probably prime (k = 1):    
    402874115778988778181873329071591767722438506891622420041029963578694595240887400867639861461466537103833299413586592359075505942560215384203202392505282949645966546812986702462936795598
    ...
    907083353780707434779613877126249098033493565718268305571578182703693122089543445743786026405786163677453587602709733484635893390989079294709002676276094965852942303062635499907856117575
    009515746557862539764756574427752110896827606786025282039152876055050854511817293890036743355523779264511
    Mersenne prime:  -1

Then it returned -1 because the mers function couldn't identify pass there.
According to https://www.mersenne.org/primes/, the following and 26th number is (2^ 23209)-1
The 26th number return was indeed the 26 Mersenne prime
    *Lab6_7> ((2 ^ 23209) - 1) ==
    402874115778988778181873329071591767722438506891622420041029963578694595240887400867639861461466537103833299413586592359075505942560215384203202392505282949645966546812986702462936795598
    ...
    907083353780707434779613877126249098033493565718268305571578182703693122089543445743786026405786163677453587602709733484635893390989079294709002676276094965852942303062635499907856117575
    009515746557862539764756574427752110896827606786025282039152876055050854511817293890036743355523779264511
    True
-}
main67 :: IO ()
main67 = doMain67 0

---------------
-- Iterators --
---------------
testMersenneMillerRabin :: Int -> [Integer] -> Int -> IO ()
testMersenneMillerRabin _ [] _ = putStr ""
testMersenneMillerRabin k (x:xs) v = do
                                      p <- primeMR k x
                                      if p then do
                                        putStrLn ("\nProbably prime (k = "++(show k)++"):  p = " ++ (show x)) 
                                        putStrLn ("Mersenne prime:  " ++ (show $ getMersenne x) )
                                        testMersenneMillerRabin k xs v
                                      else do
                                        if (v == 1) then putStrLn ("\nComposite: p = " ++ (show x)) else putStr ""
                                        testMersenneMillerRabin k xs v

-------------
-- Helpers --
-------------
-- List of Mersenne primes from Lecture6 (1 - 25)
mers' :: [Integer]
mers' = map mers [1..25]

-- Check if p is a known Mersenne prime
isMersenne :: Integer -> Bool
isMersenne p = (length $ elemIndices p mers') == 1

-- Get the index of the Mersenne prime or -1 if it's not a (known) Mersenne prime
getMersenne :: Integer -> Int
getMersenne p 
  | isMersenne p  = succ $ head $ elemIndices p mers'
  | otherwise     = -1

-- If verbose, only print cases which return "Probably prime" otherwise print all test cases
doMain67 :: Int -> IO ()
doMain67 verbose = do
  putStrLn ("Looking for Marsenne primes")
  let k = 1024
  let xs = map (\x -> pred (2^x)) primes
  testMersenneMillerRabin k xs verbose
  
-- Print all test cases
verboseMain67 :: IO ()
verboseMain67 = doMain67 1

