module Lab4_7 where

import Data.List
import System.Random
import Test.QuickCheck    
import SetOrd
import Lab4_2
import Lab4_5
import Lab4_6

-- 90 min

-- Quetion: Can you use QuickCheck?
-- Answer: I assume so, but I can't get the QuickCheck generator working so for me it's not possible

-- Taken form lectur 2
infix 1 --> 

(-->) :: Bool -> Bool -> Bool
p --> q = (not p) || q

----------------
-- Properties --
----------------

-- For every element (a,b) there should be an element (b,a)
isSymmetric :: Eq a => Rel a -> Bool
isSymmetric rs = all (\r -> flipRelExists r rs) rs

-- All relations (x,z) already exist
isTransitive :: Eq a => Rel a -> Bool
isTransitive rs = all (\r -> elem r rs) (rs @@ rs)

-- Closure should contain all elements from the original relation
containsRel :: Eq a => Rel a -> Rel a -> Bool
containsRel rs cl = all (\r -> elem r cl) rs

-- Removing one pair will break the closure
isMinimumSC :: Eq a => Rel a -> Bool
isMinimumSC rs = all (\r -> let (a,b) = r in ((a /= b) --> (not (isSymmetric (delete r rs))))) rs

-- Removing one element that is not in the original relation will break the closure
isMinimumTC :: Eq a => Rel a -> Rel a -> Bool
isMinimumTC cl rs =  (all (\r -> (not (elem r rs)) --> (not (isTransitive (delete r cl)))) cl)

isSymClos :: Eq a => Rel a -> Rel a -> Bool
isSymClos cl rs = (isSymmetric cl) && (containsRel rs cl) && (isMinimumSC cl)

isTrClos :: Eq a => Rel a -> Rel a -> Bool
isTrClos cl rs = (isTransitive cl) && (containsRel rs cl) && (isMinimumTC cl rs)

-----------
-- Tests --
-----------

-----------------------------
-- Symmetric Closure Tests --
-----------------------------

-- Check if symClos is symmetric
testIsSymmetric :: IO ()
testIsSymmetric = do
                    let n     = 100
                    rels      <- genRels n
                    let cases = map symClos rels
                    propTester_4_7_1 n isSymmetric cases
{-
testIsSymmetric
...
"Passed on: [(0,0),(0,1),(0,2),(0,3),(1,0),(1,2),(1,3),(1,4),(2,0),(2,1),(2,2),(2,3),(3,0),(3,1),(3,2),(4,1)]"
"Passed on: [(0,0),(0,1),(0,2),(0,3),(0,4),(0,6),(0,7),(0,8),(0,9),(0,10),(0,11),(1,0),(1,2),(1,3),(1,4),(1,5),(1,7),(1,8),(1,9),(1,10),(2,0),(2,1),(2,3),(2,4),(2,5),(2,6),(2,7),(2,8),(2,9),(2,11),(3,0),(3,1),(3,2),(3,3),(3,4),(3,5),(3,6),(3,7),(3,8),(3,9),(3,11),(4,0),(4,1),(4,2),(4,3),(5,1),(5,2),(5,3),(6,0),(6,2),(6,3),(7,0),(7,1),(7,2),(7,3),(8,0),(8,1),(8,2),(8,3),(9,0),(9,1),(9,2),(9,3),(10,0),(10,1),(11,0),(11,2),(11,3)]"
"Passed on: [(0,0),(0,1),(0,2),(0,4),(0,5),(0,6),(0,8),(1,0),(1,1),(1,2),(1,3),(1,4),(1,7),(1,8),(2,0),(2,1),(2,2),(2,4),(2,5),(2,7),(3,1),(3,5),(3,7),(3,8),(4,0),(4,1),(4,2),(4,4),(4,6),(4,7),(5,0),(5,2),(5,3),(5,6),(5,7),(5,8),(6,0),(6,4),(6,5),(6,6),(6,8),(7,1),(7,2),(7,3),(7,4),(7,5),(7,7),(7,8),(8,0),(8,1),(8,3),(8,5),(8,6),(8,7)]"
"Passed on: [(0,0),(0,1),(0,2),(0,4),(1,0),(1,1),(2,0),(4,0)]"
"Passed on: [(0,0),(0,1),(0,2),(0,3),(0,4),(1,0),(2,0),(3,0),(4,0)]"
"Passed all tests"
-}

-- Check if this is the min relation (including original) to make the relation a symmetric closure
testIsMinimumSC :: IO ()
testIsMinimumSC = do
                    let n     = 100
                    rels      <- genRels n
                    let cases = map symClos rels
                    propTester_4_7_1 n isMinimumSC cases
{-
testIsMinimumSC
...
"Passed on: [(0,0),(0,1),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(1,0),(1,2),(1,3),(1,4),(1,5),(1,7),(1,8),(1,9),(2,1),(2,3),(2,5),(2,6),(3,0),(3,1),(3,2),(3,4),(3,6),(3,8),(3,9),(4,0),(4,1),(4,3),(4,4),(4,6),(4,7),(4,8),(4,9),(5,0),(5,1),(5,2),(5,6),(5,7),(6,0),(6,2),(6,3),(6,4),(6,5),(6,6),(6,7),(7,0),(7,1),(7,4),(7,5),(7,6),(8,0),(8,1),(8,3),(8,4),(9,0),(9,1),(9,3),(9,4)]"
"Passed on: [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,8),(0,10),(0,11),(0,12),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(1,9),(1,10),(1,11),(2,0),(2,1),(2,3),(2,4),(2,5),(2,7),(2,8),(2,9),(2,10),(2,12),(3,0),(3,1),(3,2),(3,3),(3,4),(3,5),(3,6),(3,7),(3,12),(4,0),(4,1),(4,2),(4,3),(4,4),(4,5),(5,0),(5,1),(5,2),(5,3),(5,4),(6,0),(6,3),(7,2),(7,3),(8,0),(8,2),(9,1),(9,2),(10,0),(10,1),(10,2),(11,0),(11,1),(12,0),(12,2),(12,3)]"
"Passed on: [(0,0),(0,1),(0,6),(1,0),(1,1),(1,3),(1,4),(1,5),(1,6),(3,1),(4,1),(5,1),(6,0),(6,1)]"
"Passed on: [(0,0),(0,1),(0,2),(1,0),(2,0)]"
"Passed on: [(0,0),(0,1),(0,2),(1,0),(2,0)]"
"Passed all tests"
-}

-- Check if the closure includes the original relation
testContainsRelSc :: IO ()
testContainsRelSc = do
                      let n     =   100
                      rels      <-  genRels n
                      let cls   =   map symClos rels
                      let cases =   zip rels cls
                      propTester_4_7_2 n containsRel cases
{-
testContainsRelSc
...
"Passed on: [(0,0),(0,2),(0,4),(0,5),(0,6),(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,0),(2,1),(2,2),(2,3),(2,5),(3,0),(3,1),(3,2),(3,3)]"
"Passed on: [(0,0)]"
"Passed on: [(0,0),(0,1),(0,3),(0,8),(1,1),(1,3),(1,7),(1,8),(2,0),(2,1),(2,5),(3,3),(3,5),(3,7),(3,8),(4,0),(4,1),(4,2),(4,3),(4,4),(4,6),(5,0),(5,4),(6,0),(6,2),(6,4),(6,6),(6,7),(7,3),(7,4),(7,5),(7,7),(7,8),(8,0)]"
"Passed on: [(0,0),(0,1),(0,2),(0,3),(0,5),(0,6),(0,7),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5)]"
"Passed on: [(0,0),(0,2),(0,3),(0,5),(0,7),(0,10),(0,12),(1,0),(1,1),(1,4),(1,5),(1,7),(1,8),(1,9),(1,10),(1,11),(2,0),(2,2),(2,6),(2,7),(2,9),(2,10),(2,12),(3,0),(3,6),(3,8),(3,9),(3,10),(3,11),(4,0),(4,1),(4,3),(4,4),(4,6),(4,7),(4,8),(4,10),(4,12),(5,0),(5,1),(5,3),(5,4),(5,5),(5,8),(5,10)]"
"Passed all tests"
-}

-- Check if the relations are symmetric closures
testIsSymClos :: IO ()
testIsSymClos = do
                  let n     =   100
                  rels      <-  genRels n
                  let cls   =   map symClos rels
                  let cases =   zip cls rels
                  propTester_4_7_2 n isSymClos cases
{-
testIsSymClos
...
"Passed on: [(0,0),(0,1),(0,2),(0,5),(0,7),(0,8),(1,1),(1,2),(1,3),(1,6),(1,7),(1,8),(2,0),(2,1),(2,2),(2,3),(2,5),(2,6),(2,7),(2,8),(3,3),(3,4),(3,5),(3,6),(3,7),(3,8),(4,0)]"
"Passed on: [(0,0),(0,1),(0,2),(0,5),(0,9),(0,10),(0,11),(1,0),(1,2),(1,4),(1,5),(1,8),(1,9),(1,10),(1,11),(2,1),(2,2),(2,5),(2,7),(2,10),(2,11),(3,1),(3,3),(3,4),(3,5),(3,7),(3,11),(4,1),(4,2),(4,3),(4,4),(4,7),(4,8),(5,0),(5,2),(5,3),(5,8),(5,9)]"
"Passed on: [(0,0),(0,2),(0,3),(0,4),(0,5)]"
"Passed on: [(0,0),(0,1),(0,2)]"
"Passed on: [(0,0),(0,4),(0,7),(1,0),(1,5),(1,7),(2,4),(2,8),(3,0),(3,4),(3,6),(4,2),(4,3),(4,4),(5,1),(5,2),(5,3),(5,4),(5,5),(5,6),(6,6),(6,7),(7,0),(7,2),(7,3),(7,5),(8,1),(8,4),(8,6),(8,7)]"
"Passed all tests"
-}

------------------------------
-- Transitive Closure Tests --
------------------------------

-- Check if trClos is transitive
testIsTransitive :: IO ()
testIsTransitive = do
                    let n     = 100
                    rels      <- genRels n
                    let cases = map trClos rels
                    propTester_4_7_1 n isTransitive cases
{-
testIsTransitive
...
"Passed on: [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(0,11),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(2,0),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(2,7),(2,8),(2,9),(2,10),(2,11),(3,0),(3,1),(3,2),(3,3),(3,4),(3,5),(3,6),(3,7),(3,8),(3,9),(3,10),(3,11),(4,0),(4,1),(4,2),(4,3),(4,4),(4,5),(4,6),(4,7),(4,8),(4,9),(4,10),(4,11),(5,0),(5,1),(5,2),(5,3),(5,4),(5,5),(5,6),(5,7),(5,8),(5,9),(5,10),(5,11)]"
"Passed on: [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(2,0),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(2,7),(2,8),(3,0),(3,1),(3,2),(3,3),(3,4),(3,5),(3,6),(3,7),(3,8),(4,0),(4,1),(4,2),(4,3),(4,4),(4,5),(4,6),(4,7),(4,8),(5,0),(5,1),(5,2),(5,3),(5,4),(5,5),(5,6),(5,7),(5,8),(6,0),(6,1),(6,2),(6,3),(6,4),(6,5),(6,6),(6,7),(6,8)]"
"Passed on: [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(2,0),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(2,7),(2,8),(2,9),(3,0),(3,1),(3,2),(3,3),(3,4),(3,5),(3,6),(3,7),(3,8),(3,9),(4,0),(4,1),(4,2),(4,3),(4,4),(4,5),(4,6),(4,7),(4,8),(4,9),(5,0),(5,1),(5,2),(5,3),(5,4),(5,5),(5,6),(5,7),(5,8),(5,9),(6,0),(6,1),(6,2),(6,3),(6,4),(6,5),(6,6),(6,7),(6,8),(6,9),(7,0),(7,1),(7,2),(7,3),(7,4),(7,5),(7,6),(7,7),(7,8),(7,9)]"
"Passed on: [(0,0),(1,0),(2,0),(2,1)]"
"Passed on: [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(2,0),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(2,7),(2,8),(2,9),(3,0),(3,1),(3,2),(3,3),(3,4),(3,5),(3,6),(3,7),(3,8),(3,9),(4,0),(4,1),(4,2),(4,3),(4,4),(4,5),(4,6),(4,7),(4,8),(4,9),(5,0),(5,1),(5,2),(5,3),(5,4),(5,5),(5,6),(5,7),(5,8),(5,9),(6,0),(6,1),(6,2),(6,3),(6,4),(6,5),(6,6),(6,7),(6,8),(6,9),(7,0),(7,1),(7,2),(7,3),(7,4),(7,5),(7,6),(7,7),(7,8),(7,9),(8,0),(8,1),(8,2),(8,3),(8,4),(8,5),(8,6),(8,7),(8,8),(8,9),(9,0),(9,1),(9,2),(9,3),(9,4),(9,5),(9,6),(9,7),(9,8),(9,9)]"
"Passed all tests"
-}

-- Check if this is the min relation (including original) to make the relation a transitive closure
testIsMinimumTc :: IO ()
testIsMinimumTc = do
                    let n     =   100
                    rels      <-  genRels n
                    let cls   =   map trClos rels
                    let cases =   zip cls rels
                    propTester_4_7_2 n isMinimumTC cases
{-
testIsMinimumTc
...
"Passed on: [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(1,6)]"
"Passed on: [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9)]"
"Passed on: [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(0,11),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(2,0),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(2,7),(2,8),(2,9),(2,10),(2,11),(3,0),(3,1),(3,2),(3,3),(3,4),(3,5),(3,6),(3,7),(3,8),(3,9),(3,10),(3,11),(4,0),(4,1),(4,2),(4,3),(4,4),(4,5),(4,6),(4,7),(4,8),(4,9),(4,10),(4,11),(5,0),(5,1),(5,2),(5,3),(5,4),(5,5),(5,6),(5,7),(5,8),(5,9),(5,10),(5,11),(6,0),(6,1),(6,2),(6,3),(6,4),(6,5),(6,6),(6,7),(6,8),(6,9),(6,10),(6,11),(7,0),(7,1),(7,2),(7,3),(7,4),(7,5),(7,6),(7,7),(7,8),(7,9),(7,10),(7,11),(8,0),(8,1),(8,2),(8,3),(8,4),(8,5),(8,6),(8,7),(8,8),(8,9),(8,10),(8,11)]"
"Passed on: [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(2,0),(2,1),(2,2),(2,3),(2,4),(2,5),(3,0),(3,1),(3,2),(3,3),(3,4),(3,5),(4,0),(4,1),(4,2),(4,3),(4,4),(4,5),(5,0),(5,1),(5,2),(5,3),(5,4),(5,5)]"
"Passed on: [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(2,0),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(2,7),(3,0),(3,1),(3,2),(3,3),(3,4),(3,5),(3,6),(3,7),(4,0),(4,1),(4,2),(4,3),(4,4),(4,5),(4,6),(4,7),(5,0),(5,1),(5,2),(5,3),(5,4),(5,5),(5,6),(5,7),(6,0),(6,1),(6,2),(6,3),(6,4),(6,5),(6,6),(6,7)]"
"Passed all tests"
-}

-- Check if the closure includes the original relation
testContainsRelTc :: IO ()
testContainsRelTc = do
                      let n     =   100
                      rels      <-  genRels n
                      let cls   =   map trClos rels
                      let cases =   zip rels cls
                      propTester_4_7_2 n containsRel cases
{-
testContainsRelTc
...
"Passed on: [(0,0),(0,2),(0,4),(1,3),(1,4),(1,6),(1,7),(2,0),(2,2),(2,5),(2,8),(3,2),(4,2),(4,5),(4,6),(5,0),(5,5),(6,0),(6,1),(6,2),(6,4),(6,5),(7,3),(7,5),(7,8),(8,0),(8,4),(8,6),(8,7)]"
"Passed on: [(0,0),(0,2),(0,3),(0,4),(0,5),(0,6),(1,0),(1,1),(1,3),(1,5),(2,0),(2,1),(2,5),(3,0),(3,2),(3,4)]"
"Passed on: [(0,0),(0,3),(0,4),(0,5),(0,6),(0,7),(1,2),(1,7),(2,0),(2,3),(2,5),(2,6),(3,0),(3,1),(3,3),(3,4),(3,5),(3,7),(4,1),(4,2),(4,3),(4,6),(5,1),(5,3),(5,5),(5,7)]"
"Passed on: [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,7),(1,2),(2,0),(2,2),(3,0),(3,1),(3,4),(3,7),(4,0),(4,3),(4,5),(4,6),(4,7),(5,4),(6,1),(6,2),(6,4)]"
"Passed on: [(0,0),(0,1),(0,4),(0,7),(1,0),(1,1),(1,2),(1,3),(1,5),(1,6),(1,7),(2,0),(2,5),(2,6),(2,7),(3,0),(3,1),(3,3),(3,4),(3,5),(4,0),(4,3),(4,4)]"
"Passed all tests"
-}

-- Check if the relations are transitive closures
testIsTrClos :: IO ()
testIsTrClos = do
                let n     =   100
                rels      <-  genRels n
                let cls   =   map trClos rels
                let cases =   zip cls rels
                propTester_4_7_2 n isTrClos cases
{-
testIsTrClos
...
"Passed on: [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(0,12),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(2,7),(2,8),(2,9),(2,10),(2,11),(2,12),(3,1),(3,2),(3,4),(3,5),(3,7),(3,8),(3,9),(3,10)]"
"Passed on: [(0,0),(0,1),(0,2),(0,3),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(1,7),(1,8),(1,9),(1,10),(2,0),(2,1),(2,2),(2,3),(2,4),(2,5),(2,8),(2,9),(2,10),(3,1),(3,2),(3,3),(3,5),(3,6),(3,7)]"
"Passed on: [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,8),(0,9),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7)]"
"Passed on: [(0,0),(0,2),(0,4),(0,6),(1,1),(1,2),(2,0),(2,2),(2,5),(3,3),(3,4),(4,0),(4,1),(4,2),(5,0),(5,1),(5,4),(6,0)]"
"Passed on: [(0,0),(1,1),(1,2),(2,0),(2,1)]"
"Passed all tests"
-}

-------------
-- Testers --
-------------

propTester_4_7_1 :: Show a => Int -> (Rel a -> Bool) -> [Rel a] -> IO ()
propTester_4_7_1 n prop []        = print ("Passed all tests")
propTester_4_7_1 n prop (c:cases) = do
                                      if(prop c) then do
                                        print ("Passed on: " ++ (show c))
                                        propTester_4_7_1 (n-1) prop cases
                                      else
                                        print ("Failed on: " ++ (show c))

propTester_4_7_2 :: Show a => Int -> (Rel a -> Rel a -> Bool) -> [(Rel a,Rel a)] -> IO ()
propTester_4_7_2 n prop []        = print ("Passed all tests")
propTester_4_7_2 n prop (c:cases) = do
                                      let (a,b) = c
                                      if(prop a b) then do
                                        print ("Passed on: " ++ (show a))
                                        propTester_4_7_2 (n-1) prop cases
                                      else
                                        print ("Failed on: " ++ (show a))

----------------
-- Generators --
----------------

-- Generate a relation [(int,int)]
genRel :: IO (Rel Int)
genRel = do
          r             <-  getRandomInt 10
          let n         =   3 + r
          let set       =   [0..n]
          let rels      =   [(a,b) | a <- set, b <- set]
          let nRels     =   (length rels) - 1
          maxElems      <-  getRandomInt (nRels)
          elems         <-  getIntL maxElems nRels
          let indices   =   (sort.nub.positive) elems
          return (map (\i -> rels !! i) indices)

-- Generate n relations [(int,int)]
genRels :: Int -> IO [Rel Int]
genRels n | n <= 0    = return []
          | otherwise = do
                          r   <- genRel
                          rs  <- genRels (n-1)
                          return (r:rs)

positive :: (Num a, Ord a) => [a] -> [a]
positive xs = filter (\x -> x >= 0) xs
